# Function

```{r, include=FALSE}
library(here)
here::i_am("function.qmd")
source(here("./_common.R"))
```

See [Function](https://docs.julialang.org/en/v1/manual/functions/)

## Declare a Function

```{julia}
function sayhi(name)
    println("Hi $name, it's great to see you!")
end
```



```{julia}
sayhi("ðŸ˜¸")
```


**Single line**

```{julia}
square(x) = x^2

square(3)
```

## Return Keyword

Like `R` the last line in the body of function is returned. 

If you want to return prematurely use `return` keyword.

```{julia}
function g(x,y)
    return x * y
    x + y
end

g(1, 2)
```

If function has no return value (called for side-effect), return `nothing` by convention.

## Infix Function

```{julia}
1 + 2 + 3

+(1,2,3)
```

## Argument-type Declaration

```{julia}
fib(n::Integer) = n â‰¤ 2 ? one(n) : fib(n-1) + fib(n-2)
```

```{julia}
fib(4)
```

## Anonymous Function

```{julia}
x -> x^2 + 2x - 1
```

The primary use for anonymous functions is passing them to functions which take other functions as arguments. 

Useful in `map(f, collection)`


## Functional Programming

 
### Map

```{julia}
ðŸ“– = [1.2, 2.7]
```



```{julia}
map(round, ðŸ“–)
```

```{julia}
map(x -> 2x + 1, ðŸ“–)
```


### Broadcast

Shorter way is to `broadcast` a function.

```{julia}
h(x) = 2x + 1
h.(ðŸ“–)
```


## Destructuring Assignment

A comma-separated list of variables (optionally wrapped in parentheses) can appear on the left side of an assignment: the value on the right side is destructured by iterating over and assigning to each variable in turn:

```{julia}
(a,b,c) = 1:3 
# or 
a, b, c = 1:3

b
```


## Multiple Return Values

A tuple is useful for return multiple values from a function.

```{julia}
function foo(a,b)
    (add = a+b, prod = a*b)
end
```


```{julia}
x = foo(2,3)

x
x.add
```

Destructuring assignment extracts each value into a variable:

```{julia}
a, b = foo(4, 5)

a
b
```