{
  "hash": "a77d8e75eeb96820384612b83c0d0dc6",
  "result": {
    "markdown": "# Function\n\n\n\n\n\nSee [Function](https://docs.julialang.org/en/v1/manual/functions/)\n\n## Declare a Function\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction sayhi(name)\n    println(\"Hi $name, it's great to see you!\")\nend\n#> sayhi (generic function with 1 method)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nsayhi(\"ðŸ˜¸\")\n#> Hi ðŸ˜¸, it's great to see you!\n```\n:::\n\n\n\n**Single line**\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nsquare(x) = x^2\n#> square (generic function with 1 method)\n\nsquare(3)\n#> 9\n```\n:::\n\n\n## Return Keyword\n\nLike `R` the last line in the body of function is returned. \n\nIf you want to return prematurely use `return` keyword.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction g(x,y)\n    return x * y\n    x + y\nend\n#> g (generic function with 1 method)\n\ng(1, 2)\n#> 2\n```\n:::\n\n\nIf function has no return value (called for side-effect), return `nothing` by convention.\n\n## Side Effect !\n\nFunction that modifys argument **in-place** are suffix with `!`.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction add_one!(V)\n    for i in 1:length(V)\n        V[i] += 1\n    end\n    return nothing\nend\n#> add_one! (generic function with 1 method)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nX = [i for i âˆˆ 1:3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nadd_one!(X)\nX\n#> 3-element Vector{Int64}:\n#>  2\n#>  3\n#>  4\n```\n:::\n\n\n## Infix Function\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n1 + 2 + 3\n#> 6\n\n+(1,2,3)\n#> 6\n```\n:::\n\n\n## Argument-type Declaration\n\n**`Integer` method**\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(n::Integer) = n â‰¤ 2 ? one(n) : fib(n-1) + fib(n-2)\n#> fib (generic function with 1 method)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(4)\n#> 3\n```\n:::\n\n\n\n**`String` method** \n\nI declare `x` as a super-type `AbstractString` to include all possible string type.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(x::AbstractString) = x^fib(length(x))\n#> fib (generic function with 2 methods)\n```\n:::\n\n\nNow `fib` has 2 methods\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmethods(fib)\n#> # 2 methods for generic function \"fib\":\n#> [1] fib(n::Integer) in Main at none:3\n#> [2] fib(x::AbstractString) in Main at none:3\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(\"abcd\")\n#> \"abcdabcdabcd\"\n```\n:::\n\n\nInput non-defined argument type will error.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(1.5)\n# This will error\n```\n:::\n\n\n\n## Anonymous Function\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nx -> x^2 + 2x - 1\n#> #45 (generic function with 1 method)\n```\n:::\n\n\nThe primary use for anonymous functions is passing them to functions which take other functions as arguments. \n\nUseful in `map(f, collection)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(x -> x^2, 1:3)\n#> 3-element Vector{Int64}:\n#>  1\n#>  4\n#>  9\n```\n:::\n\n\n\n## Functional Programming\n\n \n### Map\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nðŸ“– = [1.2, 2.7]\n#> 2-element Vector{Float64}:\n#>  1.2\n#>  2.7\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(round, ðŸ“–)\n#> 2-element Vector{Float64}:\n#>  1.0\n#>  3.0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(x -> 2x + 1, ðŸ“–)\n#> 2-element Vector{Float64}:\n#>  3.4\n#>  6.4\n```\n:::\n\n\n\n### Broadcast\n\nShorter way is to `broadcast` a function.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nh(x) = 2x + 1\n#> h (generic function with 1 method)\nh.(ðŸ“–)\n#> 2-element Vector{Float64}:\n#>  3.4\n#>  6.4\n```\n:::\n\n\n\n\n\n## Multiple Return Values\n\nA tuple is useful for return multiple values from a function.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction foo(a,b)\n    (add = a+b, prod = a*b)\nend\n#> foo (generic function with 1 method)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nx = foo(2,3)\n#> (add = 5, prod = 6)\n\nx\n#> (add = 5, prod = 6)\nx.add\n#> 5\n```\n:::\n\n\n## Destructuring Assignment\n\nA comma-separated list of variables (optionally wrapped in parentheses) can appear on the left side of an assignment: the value on the right side is destructured by iterating over and assigning to each variable in turn:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n(a,b,c) = 1:3 \n#> 1:3\n# or \na, b, c = 1:3\n#> 1:3\n\nb\n#> 2\n```\n:::\n\n\n\nDestructuring assignment extracts each value from function into a variable:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\na, b = foo(4, 5)\n#> (add = 9, prod = 20)\n\na\n#> 9\nb\n#> 20\n```\n:::\n\n\n**Underscore `_`**\n\nIf only a subset of the elements of the iterator are required, a common convention is to assign ignored elements to a variable consisting of only underscores _ \n\n\n::: {.cell}\n\n```{.julia .cell-code}\n_, _, _, d = 1:10\n#> 1:10\n\nd\n#> 4\n```\n:::\n\n\n**slurping `...`**\n\nIf the last symbol in the assignment list is suffixed by `...` (known as *slurping*), then it will be assigned a collection or lazy iterator of the remaining elements of the right-hand side iterator:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\na, b... = \"hello\"\n#> \"hello\"\n\na\n#> 'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)\nb\n#> \"ello\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n_, a, b... = 1:5\n#> 1:5\n\na\n#> 2\nb\n#> 3-element Vector{Int64}:\n#>  3\n#>  4\n#>  5\n```\n:::\n\n\n\n## Argument destructuring\n\nIf a function argument name is written as a tuple (e.g. (x, y)) instead of just a symbol, then an assignment (x, y) = argument will be inserted for you:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ngap((min, max)) = max - min\n#> gap (generic function with 1 method)\ngap((1, 3))\n#> 2\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nminmax(x, y) = (y < x) ? (y, x) : (x, y)\n#> minmax (generic function with 1 method)\nminmax(3, 2)\n#> (2, 3)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nminmax(3, 2) |> gap\n#> 1\n```\n:::\n\n\nNotice the `|>` pipe operator.\n\n\nFor anonymous functions, destructuring a single tuple requires an extra comma:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(((x,y),) -> x + y, [(1,2), (3,4)])\n#> 2-element Vector{Int64}:\n#>  3\n#>  7\n```\n:::",
    "supporting": [
      "function_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}