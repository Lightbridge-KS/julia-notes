{
  "hash": "0dd2edfff2f73ee8048ca31a4f0399be",
  "result": {
    "markdown": "# String\n\n\n\n\n\n\n## Create String\n\nEnclose your String in \" \" or \"\"\" \"\"\"!\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ns1 = \"I am a string.\"\n#> \"I am a string.\"\ntypeof(s1)\n#> String\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ns2 = \"\"\"I am also a string. \"\"\"\n#> \"I am also a string. \"\ntypeof(s2)\n#> String\n```\n:::\n\n\nMulti-line string should enclosed with triple quotes. The indentation will be ignored by Julia to improve readablility.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ns = \"\"\"\n    This is a big multiline string with a nested \"quotation\".\n    As you can see.\n    It is still a String to Julia.\n    \"\"\"\n#> \"This is a big multiline string with a nested \\\"quotation\\\".\\nAs you can see.\\nIt is still a String to Julia.\\n\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nprint(s)\n#> This is a big multiline string with a nested \"quotation\".\n#> As you can see.\n#> It is still a String to Julia.\n```\n:::\n\n\nSingle quote is for `Char`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof('a')\n#> Char\n```\n:::\n\n\n## String Interpolation\n\nSimilar to shell\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nname = \"Joe\"\nnum_fingers = 10\nnum_toes = 10\n```\n:::\n\n\nUse `$` to refer to variable.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nprintln(\"Hello, my name is $name.\")\n#> Hello, my name is Joe.\nprintln(\"I have $num_fingers fingers and $num_toes toes.\")\n#> I have 10 fingers and 10 toes.\n```\n:::\n\n\nRun expression in `$(command)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nprintln(\"That is $(num_fingers + num_toes) digits in all!!\")\n#> That is 20 digits in all!!\n```\n:::\n\n\n## Concatenate String\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ns3 = \"How many cats \";\ns4 = \"is too many cats?\";\nðŸ˜º = 10\n```\n:::\n\n\n`string()` converts non-string inputs to strings.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nstring(s3, s4)\n#> \"How many cats is too many cats?\"\n```\n:::\n\n\nWe can also use `*` for concatenation!\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ns3 * s4\n#> \"How many cats is too many cats?\"\n```\n:::\n\n\n\n`join()` is better. It allows specifying `delim` and `last` separactor\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfruit = [\"apples\", \"bananas\", \"pineapples\"]\n#> 3-element Vector{String}:\n#>  \"apples\"\n#>  \"bananas\"\n#>  \"pineapples\"\n\njoin(fruit, \", \", \" and \")\n#> \"apples, bananas and pineapples\"\n```\n:::\n\n\n\n\n## Vectorize String\n\nLet's greet some people\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nh = \"Hello\"\n#> \"Hello\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\npeople = [\"Marty\", \"Johny\"]\n#> 2-element Vector{String}:\n#>  \"Marty\"\n#>  \"Johny\"\ntypeof(people)\n#> Vector{String} (alias for Array{String, 1})\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nstring.(h, \" \", people)\n#> 2-element Vector{String}:\n#>  \"Hello Marty\"\n#>  \"Hello Johny\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nh .* \" \" .* people\n#> 2-element Vector{String}:\n#>  \"Hello Marty\"\n#>  \"Hello Johny\"\n```\n:::\n\n\nNow write function `hello()` with 2 methods\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nhello(people::AbstractString) = \"Hello\" * \" \" * people\n#> hello (generic function with 1 method)\nhello(people::AbstractArray) = \"Hello\" .* \" \" .* people\n#> hello (generic function with 2 methods)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmethods(hello)\n#> # 2 methods for generic function \"hello\":\n#> [1] hello(people::AbstractString) in Main at none:3\n#> [2] hello(people::AbstractArray) in Main at none:3\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nhello(\"A\")\n#> \"Hello A\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nstudents = [\"Harry\", \"Ron\"]\n#> 2-element Vector{String}:\n#>  \"Harry\"\n#>  \"Ron\"\nhello(students)\n#> 2-element Vector{String}:\n#>  \"Hello Harry\"\n#>  \"Hello Ron\"\n```\n:::\n\n\n## String Manipulation\n\n\n::: {.cell}\n\n```{.julia .cell-code}\njulia_string = \"Julia is an amazing open source programming language\"\n#> \"Julia is an amazing open source programming language\"\n```\n:::\n\n\nRegex define with `r`\"text\"\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nr\"sometext\"\n#> r\"sometext\"\ntypeof(r\"sometext\")\n#> Regex\n```\n:::\n\n\n### Conditional Testing\n\n**substring** of the first argument\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ncontains(julia_string, \"Julia\")\n#> true\n# Regex\ncontains(julia_string, r\"J.+e$\")\n#> true\n```\n:::\n\n\n**Starts With** of the first argument\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nstartswith(julia_string, \"Julia\")\n#> true\n```\n:::\n\n\n**Ends With** of the first argument\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nendswith(julia_string, \"Julia\")\n#> false\n```\n:::\n\n\n### Change Cases\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nlowercase(julia_string)\n#> \"julia is an amazing open source programming language\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nuppercase(julia_string)\n#> \"JULIA IS AN AMAZING OPEN SOURCE PROGRAMMING LANGUAGE\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntitlecase(julia_string)\n#> \"Julia Is An Amazing Open Source Programming Language\"\n```\n:::\n\n\n### Replace & Split\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nreplace(\"R is a programming language.\", \"R\" => \"Julia\")\n#> \"Julia is a programming language.\"\n```\n:::\n\n\n`count` args\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nreplace(\"R user comes from useR.\", \"R\" => \"Julia\")\n#> \"Julia user comes from useJulia.\"\nreplace(\"R user comes from useR.\", \"R\" => \"Julia\", count=1)\n#> \"Julia user comes from useR.\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nsplit(\"a b c d\")\n#> 4-element Vector{SubString{String}}:\n#>  \"a\"\n#>  \"b\"\n#>  \"c\"\n#>  \"d\"\nsplit(\"a, b, c, d\", r\"\\s*,\\s*\")\n#> 4-element Vector{SubString{String}}:\n#>  \"a\"\n#>  \"b\"\n#>  \"c\"\n#>  \"d\"\n```\n:::\n\n\n## String Conversion\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nparse(Int64, \"123\")\n#> 123\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nparse(Int64, \"a\") # Error\n```\n:::\n\n\nSilently parse to `nothing`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ntryparse(Int64, \"A very non-numeric string\")\n```\n:::\n\n\n## Exercise\n\nCreate a string that says \"hi\" 3 times, first with repeat and then with the exponentiation operator, which can call * under the hood. Assign it the variable hi below.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nrepeat(\"hi\", 3)\n#> \"hihihi\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n\"hi\"^3\n#> \"hihihi\"\n```\n:::\n\n\n\nDeclare two variables\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\na = 3\nb = 4\n```\n:::\n\n\nand use them to create two strings:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nc = string(a) * \" + \" * string(b)\n#> \"3 + 4\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nd = string(a + b)\n#> \"7\"\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}