{
  "hash": "7bb7b4441aedc226390078464b40679c",
  "result": {
    "markdown": "# Data Structure\n\n\n\n\n\n\n\nTypes of data structures covered:\n\n1. **Tuples**: unmutable, ordered or named, subset with integer `tup[1]` or dot notation `tup.key`\n\n2. **Ranges**: `start:step` or `start:step:stop`\n\n3. **Dictionaries**: mutable, named only, subset with name only `dct[\"key\"]`.\n\n4. **Arrays**: mutable, ordered only, can mixed type of elements, subset with `arr[1]`\n\ntuples and arrays are both ordered sequences of elements (so we can index into them). Dictionaries and arrays are both mutable. \n\nJulia is *1* indexing.\n\n\n## Tuples\n\nWe can create a tuple by enclosing an ordered collection of elements in `( )`.\n\nTuple can be named or unnamed. \n\n`(name1 = item1, name2 = item2, ...)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims = (\"penguins\", \"cats\", \"sugargliders\")\n#> (\"penguins\", \"cats\", \"sugargliders\")\nfav_anims_named = (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\")\n#> (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\")\n\n# Indexing\nfav_anims[1]\n#> \"penguins\"\nfav_anims_named[2]\n#> \"cats\"\n\n# Dot Notation\nfav_anims_named.bird\n#> \"penguins\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof(fav_anims)\n#> Tuple{String, String, String}\ntypeof(fav_anims_named)\n#> NamedTuple{(:bird, :mammal, :marsupial), Tuple{String, String, String}}\n```\n:::\n\n\nSubset first & Last value\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims[begin]\n#> \"penguins\"\nfav_anims[end]\n#> \"sugargliders\"\n```\n:::\n\n\nTuples is unmutable. This will get Error.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims[1] = \"Otters\" # Error\n```\n:::\n\n\n### Tuple construction from variables\n\nspecifying first a semicolon before the values. \n\n\n::: {.cell}\n\n```{.julia .cell-code}\ni = 1\n#> 1\nf = 3.14\n#> 3.14\ns = \"Julia\"\n#> \"Julia\"\n\nmy_quick_namedtuple = (; i, f, s)\n#> (i = 1, f = 3.14, s = \"Julia\")\n```\n:::\n\n\n## Ranges\n\nRange object\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n1:10\n#> 1:10\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof(1:10)\n#> UnitRange{Int64}\n\n# Other types\ntypeof(1.0:10.0)\n#> StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n```\n:::\n\n\nGather values by \n\n**`for` Loop**\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[i for i in 1:2:10]\n#> 5-element Vector{Int64}:\n#>  1\n#>  3\n#>  5\n#>  7\n#>  9\n```\n:::\n\n\n**`collect()`**\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ncollect(1:2:10)\n#> 5-element Vector{Int64}:\n#>  1\n#>  3\n#>  5\n#>  7\n#>  9\n```\n:::\n\n\n\n## Dictionary\n\n`Dict(key1 => value1, key2 => value2, ...)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook = Dict(\"Jenny\" => \"867-5309\", \"Ghostbusters\" => \"555-2368\")\n#> Dict{String, String} with 2 entries:\n#>   \"Jenny\"        => \"867-5309\"\n#>   \"Ghostbusters\" => \"555-2368\"\n```\n:::\n\n\nor construct by tuples:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nDict( [(\"A\", 1), (\"B\", 2)] )\n#> Dict{String, Int64} with 2 entries:\n#>   \"B\" => 2\n#>   \"A\" => 1\n```\n:::\n\n\nSubset with Key \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook[\"Jenny\"]\n#> \"867-5309\"\n```\n:::\n\n\nAdd another item\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook[\"Kramer\"] = \"555-FILK\"\n#> \"555-FILK\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook\n#> Dict{String, String} with 3 entries:\n#>   \"Jenny\"        => \"867-5309\"\n#>   \"Kramer\"       => \"555-FILK\"\n#>   \"Ghostbusters\" => \"555-2368\"\n```\n:::\n\n\nRemove Item (modify in-place)\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npop!(myphonebook, \"Kramer\")\n#> \"555-FILK\"\n```\n:::\n\n\n\n## Arrays\n\n### Introduction\n\n`[item1, item2, ...]`\n\nsimilar to R vector\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"]\n#> 5-element Vector{String}:\n#>  \"Ted\"\n#>  \"Robyn\"\n#>  \"Barney\"\n#>  \"Lily\"\n#>  \"Marshall\"\n```\n:::\n\n\n`Array{String,1}` means this is a one dimensional vector. An `Array{String,2}` would be a 2d matrix.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfibonacci = [1, 1, 2, 3, 5, 8, 13]\n#> 7-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmixture = [1, 1, 2, 3, \"Ted\", \"Robyn\"]\n#> 6-element Vector{Any}:\n#>  1\n#>  1\n#>  2\n#>  3\n#>   \"Ted\"\n#>   \"Robyn\"\nmixture[1]\n#> 1\n```\n:::\n\n\n### Formal Array Contruction\n\n-   `Vector{T}`: one-dimensional array. Alias for `Array{T, 1}`.\n-   `Matrix{T}`: two-dimensional array. Alias for `Array{T, 2}`.\n\n\nCreate vector (1d array) with type `Float64`. It has undefined 5 element \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmy_V = Vector{Float64}(undef, 3)\n#> 3-element Vector{Float64}:\n#>  2.1344081666e-314\n#>  2.134408388e-314\n#>  2.364432689e-314\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nlength(my_V)\n#> 3\n```\n:::\n\n\nCreate 2 x 3 Matrix with element undefined.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmy_M = Matrix{Int}(undef, 2, 3)\n#> 2×3 Matrix{Int64}:\n#>           0  4785665040  4786082464\n#>  4786082464           0  4785665040\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nlength(my_M) # Number of elements\n#> 6\n\nndims(my_M)  # Dims\n#> 2\n\nsize(my_M) # Size (shape) of Matrix\n#> (2, 3)\n```\n:::\n\n\nThen fill array with\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfill!(my_V, 4)\n#> 3-element Vector{Float64}:\n#>  4.0\n#>  4.0\n#>  4.0\nmy_V\n#> 3-element Vector{Float64}:\n#>  4.0\n#>  4.0\n#>  4.0\n```\n:::\n\n\n\n\n\n`push!` adds an element to the end of an array and `pop!` removes the last element of an array.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npush!(my_V, 21)\n#> 4-element Vector{Float64}:\n#>   4.0\n#>   4.0\n#>   4.0\n#>  21.0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\npop!(my_V)\n#> 21.0\n```\n:::\n\n\nzeros array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nzeros(3)\n#> 3-element Vector{Float64}:\n#>  0.0\n#>  0.0\n#>  0.0\n```\n:::\n\n\nones array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nones(2)\n#> 2-element Vector{Float64}:\n#>  1.0\n#>  1.0\nones(Int, 2, 3)\n#> 2×3 Matrix{Int64}:\n#>  1  1  1\n#>  1  1  1\n```\n:::\n\n\n### Array literals\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfavorites = [\n    [\"koobideh\", \"chocolate\", \"eggs\"],\n    [\"penguins\", \"cats\", \"sugargliders\"]\n    ]\n#> 2-element Vector{Vector{String}}:\n#>  [\"koobideh\", \"chocolate\", \"eggs\"]\n#>  [\"penguins\", \"cats\", \"sugargliders\"]\n```\n:::\n\n\nArray literals also accept a type specification\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nFloat64[1 2; 3 4]\n#> 2×2 Matrix{Float64}:\n#>  1.0  2.0\n#>  3.0  4.0\n```\n:::\n\n\nMix and match\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[ones(Int, 2, 2) zeros(Int, 2, 2)]\n#> 2×4 Matrix{Int64}:\n#>  1  1  0  0\n#>  1  1  0  0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n[zeros(Int, 2, 2)\n ones(Int, 2, 2)]\n#> 4×2 Matrix{Int64}:\n#>  0  0\n#>  0  0\n#>  1  1\n#>  1  1\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nrand(4, 3)\n#> 4×3 Matrix{Float64}:\n#>  0.708228  0.246062  0.660766\n#>  0.973862  0.377012  0.0082465\n#>  0.404015  0.324269  0.0492449\n#>  0.683777  0.485667  0.842699\n```\n:::\n\n\n### Array Indexing and Slicing\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nV = [1, 2, 3, 4, 5]\n#> 5-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n#>  5\n\nM = [[1 2 3];\n     [4 5 6];\n     [7 8 9]]\n#> 3×3 Matrix{Int64}:\n#>  1  2  3\n#>  4  5  6\n#>  7  8  9\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nV[1:3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n\n# First and Last Value\nV[begin]\n#> 1\nV[end]\n#> 5\n```\n:::\n\n\nCan't use negative index, however.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nV[-1]\n# Error\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nM[2, 1]\n#> 4\n\nM[2:3, 1]\n#> 2-element Vector{Int64}:\n#>  4\n#>  7\n```\n:::\n\n\n\n### Copy Array\n\nThe correct way is\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nsomemorenumbers = copy(fibonacci)\n#> 7-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n```\n:::\n\n\nwhich will bound to different memory ID.\n\n## Array Comprehension\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[x^2 for x in 1:3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  4\n#>  9\n```\n:::\n\n\nMultiple inputs also support.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[string(x, \"-\", y) for x in 1:3 for y in 1:2]\n#> 6-element Vector{String}:\n#>  \"1-1\"\n#>  \"1-2\"\n#>  \"2-1\"\n#>  \"2-2\"\n#>  \"3-1\"\n#>  \"3-2\"\n```\n:::\n\n\nAdd conditionals:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[x^2 for x in 1:10 if isodd(x)]\n#> 5-element Vector{Int64}:\n#>   1\n#>   9\n#>  25\n#>  49\n#>  81\n```\n:::\n\n\n## Array Manipulation\n\n**Concatenate array**\n\n-   `cat()`: concatenate input arrays along a specific dimension `dims`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ncat(ones(2), zeros(2), dims=1)\n#> 4-element Vector{Float64}:\n#>  1.0\n#>  1.0\n#>  0.0\n#>  0.0\n```\n:::\n\n\n-   `vcat()`: vertical concatenation\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nvcat(ones(2), zeros(2))\n#> 4-element Vector{Float64}:\n#>  1.0\n#>  1.0\n#>  0.0\n#>  0.0\n```\n:::\n\n\n-   `hcat()`: horizontal concatenation\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nhcat(ones(2), zeros(2))\n#> 2×2 Matrix{Float64}:\n#>  1.0  0.0\n#>  1.0  0.0\n```\n:::\n\n\n## Exercise\n\n\n::: {.cell}\n\n```{.julia .cell-code}\na_ray = [1, 2, 3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n\n# Add 4\npush!(a_ray, 4)\n#> 4-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n# Remove 4\npop!(a_ray)\n#> 4\n\na_ray\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}