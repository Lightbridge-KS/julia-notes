{
  "hash": "94a0957f34fa73ed9914a799fd4f40d6",
  "result": {
    "markdown": "# Data Structure\n\n\n\n\n\n\n\nTypes of data structures covered:\n\n1. **Tuples**: unmutable, ordered or named, subset with integer `tup[1]` or dot notation `tup.key`\n\n2. **Dictionaries**: mutable, named only, subset with name only `dct[\"key\"]`.\n\n3. **Arrays**: mutable, ordered only, can mixed type of elements, subset with `arr[1]`\n\ntuples and arrays are both ordered sequences of elements (so we can index into them). Dictionaries and arrays are both mutable. \n\nJulia is *1* indexing.\n\n\n## Tuples\n\nWe can create a tuple by enclosing an ordered collection of elements in `( )`.\n\nTuple can be named or unnamed. \n\n`(name1 = item1, name2 = item2, ...)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims = (\"penguins\", \"cats\", \"sugargliders\")\n#> (\"penguins\", \"cats\", \"sugargliders\")\nfav_anims_named = (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\")\n#> (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\")\n\n# Indexing\nfav_anims[1]\n#> \"penguins\"\nfav_anims_named[2]\n#> \"cats\"\n\n# Dot Notation\nfav_anims_named.bird\n#> \"penguins\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof(fav_anims)\n#> Tuple{String, String, String}\ntypeof(fav_anims_named)\n#> NamedTuple{(:bird, :mammal, :marsupial), Tuple{String, String, String}}\n```\n:::\n\n\nSubset first & Last value\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims[begin]\n#> \"penguins\"\nfav_anims[end]\n#> \"sugargliders\"\n```\n:::\n\n\nTuples is unmutable. This will get Error.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims[1] = \"Otters\" # Error\n```\n:::\n\n\n## Dictionary\n\n`Dict(key1 => value1, key2 => value2, ...)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook = Dict(\"Jenny\" => \"867-5309\", \"Ghostbusters\" => \"555-2368\")\n#> Dict{String, String} with 2 entries:\n#>   \"Jenny\"        => \"867-5309\"\n#>   \"Ghostbusters\" => \"555-2368\"\n```\n:::\n\n\nor construct by tuples:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nDict( [(\"A\", 1), (\"B\", 2)] )\n#> Dict{String, Int64} with 2 entries:\n#>   \"B\" => 2\n#>   \"A\" => 1\n```\n:::\n\n\nSubset with Key \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook[\"Jenny\"]\n#> \"867-5309\"\n```\n:::\n\n\nAdd another item\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook[\"Kramer\"] = \"555-FILK\"\n#> \"555-FILK\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook\n#> Dict{String, String} with 3 entries:\n#>   \"Jenny\"        => \"867-5309\"\n#>   \"Kramer\"       => \"555-FILK\"\n#>   \"Ghostbusters\" => \"555-2368\"\n```\n:::\n\n\nRemove Item (modify in-place)\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npop!(myphonebook, \"Kramer\")\n#> \"555-FILK\"\n```\n:::\n\n\n\n## Arrays\n\n`[item1, item2, ...]`\n\nsimilar to R vector\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"]\n#> 5-element Vector{String}:\n#>  \"Ted\"\n#>  \"Robyn\"\n#>  \"Barney\"\n#>  \"Lily\"\n#>  \"Marshall\"\n```\n:::\n\n\n`Array{String,1}` means this is a one dimensional vector. An `Array{String,2}` would be a 2d matrix.\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfibonacci = [1, 1, 2, 3, 5, 8, 13]\n#> 7-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmixture = [1, 1, 2, 3, \"Ted\", \"Robyn\"]\n#> 6-element Vector{Any}:\n#>  1\n#>  1\n#>  2\n#>  3\n#>   \"Ted\"\n#>   \"Robyn\"\nmixture[1]\n#> 1\n```\n:::\n\n\n\n\n`push!` adds an element to the end of an array and `pop!` removes the last element of an array.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npush!(fibonacci, 21)\n#> 8-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n#>  21\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\npop!(fibonacci)\n#> 21\n```\n:::\n\n\n### Multi-dims Array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfavorites = [\n    [\"koobideh\", \"chocolate\", \"eggs\"],\n    [\"penguins\", \"cats\", \"sugargliders\"]\n    ]\n#> 2-element Vector{Vector{String}}:\n#>  [\"koobideh\", \"chocolate\", \"eggs\"]\n#>  [\"penguins\", \"cats\", \"sugargliders\"]\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nrand(4, 3)\n#> 4Ã—3 Matrix{Float64}:\n#>  0.205309   0.867579   0.598126\n#>  0.0416623  0.0442032  0.826039\n#>  0.129189   0.910989   0.667986\n#>  0.0980359  0.144535   0.40367\n```\n:::\n\n\n### Copy Array\n\nThe correct way is\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nsomemorenumbers = copy(fibonacci)\n#> 7-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n```\n:::\n\n\nwhich will bound to different memory ID.\n\n\n## Exercise\n\n\n::: {.cell}\n\n```{.julia .cell-code}\na_ray = [1, 2, 3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n\n# Add 4\npush!(a_ray, 4)\n#> 4-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n# Remove 4\npop!(a_ray)\n#> 4\n\na_ray\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}