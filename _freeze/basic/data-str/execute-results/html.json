{
  "hash": "f0718465ba17f3b0d875e6f953375792",
  "result": {
    "markdown": "# Data Structure\n\n\n\n\n\n\n\nTypes of data structures covered:\n\n1. **Tuples**: unmutable, ordered or named, subset with integer `tup[1]` or dot notation `tup.key`\n\n2. **Ranges**: `start:step` or `start:step:stop`\n\n3. **Dictionaries**: mutable, named only, subset with name only `dct[\"key\"]`.\n\n4. **Arrays**: mutable, ordered only, can mixed type of elements, subset with `arr[1]`\n\ntuples and arrays are both ordered sequences of elements (so we can index into them). Dictionaries and arrays are both mutable. \n\nJulia is *1* indexing.\n\n\n## Tuples\n\nWe can create a tuple by enclosing an ordered collection of elements in `( )`.\n\nTuple can be named or unnamed. \n\n`(name1 = item1, name2 = item2, ...)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims = (\"penguins\", \"cats\", \"sugargliders\")\n#> (\"penguins\", \"cats\", \"sugargliders\")\nfav_anims_named = (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\")\n#> (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\")\n\n# Indexing\nfav_anims[1]\n#> \"penguins\"\nfav_anims_named[2]\n#> \"cats\"\n\n# Dot Notation\nfav_anims_named.bird\n#> \"penguins\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof(fav_anims)\n#> Tuple{String, String, String}\ntypeof(fav_anims_named)\n#> NamedTuple{(:bird, :mammal, :marsupial), Tuple{String, String, String}}\n```\n:::\n\n\nSubset first & Last value\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims[begin]\n#> \"penguins\"\nfav_anims[end]\n#> \"sugargliders\"\n```\n:::\n\n\nTuples is unmutable. This will get Error.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfav_anims[1] = \"Otters\" # Error\n```\n:::\n\n\n### Tuple construction from variables\n\nspecifying first a semicolon before the values. \n\n\n::: {.cell}\n\n```{.julia .cell-code}\ni = 1\n#> 1\nf = 3.14\n#> 3.14\ns = \"Julia\"\n#> \"Julia\"\n\nmy_quick_namedtuple = (; i, f, s)\n#> (i = 1, f = 3.14, s = \"Julia\")\n```\n:::\n\n\n## Ranges\n\nRange object\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n1:10\n#> 1:10\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof(1:10)\n#> UnitRange{Int64}\n\n# Other types\ntypeof(1.0:10.0)\n#> StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n```\n:::\n\n\nGather values by \n\n**`for` Loop**\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[i for i in 1:2:10]\n#> 5-element Vector{Int64}:\n#>  1\n#>  3\n#>  5\n#>  7\n#>  9\n```\n:::\n\n\n**`collect()`**\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ncollect(1:2:10)\n#> 5-element Vector{Int64}:\n#>  1\n#>  3\n#>  5\n#>  7\n#>  9\n```\n:::\n\n\n## Pairs\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmy_pair = \"Julia\" => 42\n#> \"Julia\" => 42\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\ntypeof(my_pair)\n#> Pair{String, Int64}\n```\n:::\n\n\npair subset\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmy_pair.first\n#> \"Julia\"\nmy_pair.second\n#> 42\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nfirst(my_pair)\n#> \"Julia\"\nlast(my_pair)\n#> 42\n```\n:::\n\n\n## Dictionary\n\n**Dict Constuction**\n\n`Dict(key1 => value1, key2 => value2, ...)`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook = Dict(\"Jenny\" => \"867-5309\", \"Ghostbusters\" => \"555-2368\")\n#> Dict{String, String} with 2 entries:\n#>   \"Jenny\"        => \"867-5309\"\n#>   \"Ghostbusters\" => \"555-2368\"\n```\n:::\n\n\nor construct by tuples:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nDict( [(\"A\", 1), (\"B\", 2)] )\n#> Dict{String, Int64} with 2 entries:\n#>   \"B\" => 2\n#>   \"A\" => 1\n```\n:::\n\n\nObtain keys by:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nkeys(myphonebook)\n#> KeySet for a Dict{String, String} with 2 entries. Keys:\n#>   \"Jenny\"\n#>   \"Ghostbusters\"\n```\n:::\n\n\nSubset with Key \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook[\"Jenny\"]\n#> \"867-5309\"\n```\n:::\n\n\nAdd another item\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook[\"Kramer\"] = \"555-FILK\"\n#> \"555-FILK\"\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyphonebook\n#> Dict{String, String} with 3 entries:\n#>   \"Jenny\"        => \"867-5309\"\n#>   \"Kramer\"       => \"555-FILK\"\n#>   \"Ghostbusters\" => \"555-2368\"\n```\n:::\n\n\nRemove Item (modify in-place)\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npop!(myphonebook, \"Kramer\")\n#> \"555-FILK\"\n```\n:::\n\n\n### Example: tuple and dict conversion\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction separate2(str::AbstractString) \n    x = split(str, r\"[^[:alnum:].]+\"; limit = 2)\n    (x[1], x[2])\nend\n#> separate2 (generic function with 1 method)\n\nseparate2(\"asdf, dfs\")\n#> (\"asdf\", \"dfs\")\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n[\"name: Mark\", \"age: 20\"] .|> separate2\n#> 2-element Vector{Tuple{SubString{String}, SubString{String}}}:\n#>  (\"name\", \"Mark\")\n#>  (\"age\", \"20\")\n```\n:::\n\n\nSeparate to dictionary\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction separate2(vec::Vector) \n    tups = separate2.(vec)\n    Dict(tups)\nend\n#> separate2 (generic function with 2 methods)\n\nseparate2([\"name: Mark\", \"age: 20\"])\n#> Dict{SubString{String}, SubString{String}} with 2 entries:\n#>   \"name\" => \"Mark\"\n#>   \"age\"  => \"20\"\n```\n:::\n\n\n\n## Arrays\n\n### Introduction\n\n`[item1, item2, ...]`\n\nsimilar to R vector\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmyfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"]\n#> 5-element Vector{String}:\n#>  \"Ted\"\n#>  \"Robyn\"\n#>  \"Barney\"\n#>  \"Lily\"\n#>  \"Marshall\"\n```\n:::\n\n\n`Array{String,1}` means this is a one dimensional vector. An `Array{String,2}` would be a 2d matrix.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfibonacci = [1, 1, 2, 3, 5, 8, 13]\n#> 7-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmixture = [1, 1, 2, 3, \"Ted\", \"Robyn\"]\n#> 6-element Vector{Any}:\n#>  1\n#>  1\n#>  2\n#>  3\n#>   \"Ted\"\n#>   \"Robyn\"\nmixture[1]\n#> 1\n```\n:::\n\n\n### Formal Array Contruction\n\n-   `Vector{T}`: one-dimensional array. Alias for `Array{T, 1}`.\n-   `Matrix{T}`: two-dimensional array. Alias for `Array{T, 2}`.\n\n\nCreate vector (1d array) with type `Float64`. It has undefined 5 element \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmy_V = Vector{Float64}(undef, 3)\n#> 3-element Vector{Float64}:\n#>  5.0e-324\n#>  5.0e-324\n#>  0.0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nlength(my_V)\n#> 3\n```\n:::\n\n\nCreate 2 x 3 Matrix with element undefined.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmy_M = Matrix{Int}(undef, 2, 3)\n#> 2×3 Matrix{Int64}:\n#>           0  5046895632  5047313056\n#>  5047313056           0  5046895632\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nlength(my_M) # Number of elements\n#> 6\n\nndims(my_M)  # Dims\n#> 2\n\nsize(my_M) # Size (shape) of Matrix\n#> (2, 3)\n```\n:::\n\n\nThen fill array with\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfill!(my_V, 4)\n#> 3-element Vector{Float64}:\n#>  4.0\n#>  4.0\n#>  4.0\nmy_V\n#> 3-element Vector{Float64}:\n#>  4.0\n#>  4.0\n#>  4.0\n```\n:::\n\n\n\n\n\n`push!` adds an element to the end of an array and `pop!` removes the last element of an array.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npush!(my_V, 21)\n#> 4-element Vector{Float64}:\n#>   4.0\n#>   4.0\n#>   4.0\n#>  21.0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\npop!(my_V)\n#> 21.0\n```\n:::\n\n\nzeros array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nzeros(3)\n#> 3-element Vector{Float64}:\n#>  0.0\n#>  0.0\n#>  0.0\n```\n:::\n\n\nones array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nones(2)\n#> 2-element Vector{Float64}:\n#>  1.0\n#>  1.0\nones(Int, 2, 3)\n#> 2×3 Matrix{Int64}:\n#>  1  1  1\n#>  1  1  1\n```\n:::\n\n\n### Array literals\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nfavorites = [\n    [\"koobideh\", \"chocolate\", \"eggs\"],\n    [\"penguins\", \"cats\", \"sugargliders\"]\n    ]\n#> 2-element Vector{Vector{String}}:\n#>  [\"koobideh\", \"chocolate\", \"eggs\"]\n#>  [\"penguins\", \"cats\", \"sugargliders\"]\n```\n:::\n\n\nArray literals also accept a type specification\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nFloat64[1 2; 3 4]\n#> 2×2 Matrix{Float64}:\n#>  1.0  2.0\n#>  3.0  4.0\n```\n:::\n\n\nMix and match\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[ones(Int, 2, 2) zeros(Int, 2, 2)]\n#> 2×4 Matrix{Int64}:\n#>  1  1  0  0\n#>  1  1  0  0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n[zeros(Int, 2, 2)\n ones(Int, 2, 2)]\n#> 4×2 Matrix{Int64}:\n#>  0  0\n#>  0  0\n#>  1  1\n#>  1  1\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nrand(4, 3)\n#> 4×3 Matrix{Float64}:\n#>  0.470263  0.300487  0.958228\n#>  0.213954  0.497404  0.299014\n#>  0.573203  0.842071  0.534293\n#>  0.911019  0.560313  0.323428\n```\n:::\n\n\n### Array Indexing and Slicing\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nV = [1, 2, 3, 4, 5]\n#> 5-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n#>  5\n\nM = [[1 2 3];\n     [4 5 6];\n     [7 8 9]]\n#> 3×3 Matrix{Int64}:\n#>  1  2  3\n#>  4  5  6\n#>  7  8  9\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nV[1:3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n\n# First and Last Value\nV[begin]\n#> 1\nV[end]\n#> 5\n```\n:::\n\n\nCan't use negative index, however.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nV[-1]\n# Error\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nM[2, 1]\n#> 4\n\nM[2:3, 1]\n#> 2-element Vector{Int64}:\n#>  4\n#>  7\n```\n:::\n\n\nselect columns\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM[2, :]\n#> 3-element Vector{Int64}:\n#>  4\n#>  5\n#>  6\n```\n:::\n\n\n### Array Manipulation\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM = [[1 2 3];\n     [4 5 6];\n     [7 8 9]]\n#> 3×3 Matrix{Int64}:\n#>  1  2  3\n#>  4  5  6\n#>  7  8  9\n```\n:::\n\n\nAssign single element\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM[1, 2] = 10\n#> 10\nM\n#> 3×3 Matrix{Int64}:\n#>  1  10  3\n#>  4   5  6\n#>  7   8  9\n```\n:::\n\n\nAssign column (or row) vector\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM[2, :] = zeros(3)\n#> 3-element Vector{Float64}:\n#>  0.0\n#>  0.0\n#>  0.0\nM\n#> 3×3 Matrix{Int64}:\n#>  1  10  3\n#>  0   0  0\n#>  7   8  9\n```\n:::\n\n\n**Reshape**\n\nReshape: Vector -> N-Dims Array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nsix_vector = collect(1:6)\n#> 6-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n#>  5\n#>  6\nthree_two_matrix = reshape(six_vector, (3, 2))\n#> 3×2 Matrix{Int64}:\n#>  1  4\n#>  2  5\n#>  3  6\nthree_two_matrix\n#> 3×2 Matrix{Int64}:\n#>  1  4\n#>  2  5\n#>  3  6\n```\n:::\n\n\nReshape: N-Dims Array -> Vector \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nvec(three_two_matrix)\n#> 6-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n#>  5\n#>  6\n```\n:::\n\n\n### Apply `Fun` over Array\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM = [[1 2 3];\n     [4 5 6];\n     [7 8 9]]\n#> 3×3 Matrix{Int64}:\n#>  1  2  3\n#>  4  5  6\n#>  7  8  9\n```\n:::\n\n\nDot syntax\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM .+ 10\n#> 3×3 Matrix{Int64}:\n#>  11  12  13\n#>  14  15  16\n#>  17  18  19\n```\n:::\n\n\n`map` function\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(x -> 2x, M)\n#> 3×3 Matrix{Int64}:\n#>   2   4   6\n#>   8  10  12\n#>  14  16  18\n```\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n(x -> 2x).(M)\n#> 3×3 Matrix{Int64}:\n#>   2   4   6\n#>   8  10  12\n#>  14  16  18\n```\n:::\n\n\n**mapslices()**\n\nApply a function over all elements in a specific array dimension.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nM2 = [1 2 3;\n      4 5 6]\n#> 2×3 Matrix{Int64}:\n#>  1  2  3\n#>  4  5  6\n```\n:::\n\n\nCols Sum\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmapslices(sum, M2; dims = 1)\n#> 1×3 Matrix{Int64}:\n#>  5  7  9\n```\n:::\n\n\nRow Sum\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmapslices(sum, M2; dims = 2)\n#> 2×1 Matrix{Int64}:\n#>   6\n#>  15\n```\n:::\n\n\n### Copy Array\n\nThe correct way is\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nsomemorenumbers = copy(fibonacci)\n#> 7-element Vector{Int64}:\n#>   1\n#>   1\n#>   2\n#>   3\n#>   5\n#>   8\n#>  13\n```\n:::\n\n\nwhich will bound to different memory ID.\n\n## Array Comprehension\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[x^2 for x in 1:3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  4\n#>  9\n```\n:::\n\n\nMultiple inputs also support.\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[string(x, \"-\", y) for x in 1:3 for y in 1:2]\n#> 6-element Vector{String}:\n#>  \"1-1\"\n#>  \"1-2\"\n#>  \"2-1\"\n#>  \"2-2\"\n#>  \"3-1\"\n#>  \"3-2\"\n```\n:::\n\n\nAdd conditionals:\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n[x^2 for x in 1:10 if isodd(x)]\n#> 5-element Vector{Int64}:\n#>   1\n#>   9\n#>  25\n#>  49\n#>  81\n```\n:::\n\n\n## Array Manipulation\n\n**Concatenate array**\n\n-   `cat()`: concatenate input arrays along a specific dimension `dims`\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ncat(ones(2), zeros(2), dims=1)\n#> 4-element Vector{Float64}:\n#>  1.0\n#>  1.0\n#>  0.0\n#>  0.0\n```\n:::\n\n\n-   `vcat()`: vertical concatenation\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nvcat(ones(2), zeros(2))\n#> 4-element Vector{Float64}:\n#>  1.0\n#>  1.0\n#>  0.0\n#>  0.0\n```\n:::\n\n\n-   `hcat()`: horizontal concatenation\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nhcat(ones(2), zeros(2))\n#> 2×2 Matrix{Float64}:\n#>  1.0  0.0\n#>  1.0  0.0\n```\n:::\n\n\n## Exercise\n\n\n::: {.cell}\n\n```{.julia .cell-code}\na_ray = [1, 2, 3]\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n\n# Add 4\npush!(a_ray, 4)\n#> 4-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n#>  4\n# Remove 4\npop!(a_ray)\n#> 4\n\na_ray\n#> 3-element Vector{Int64}:\n#>  1\n#>  2\n#>  3\n```\n:::",
    "supporting": [
      "data-str_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}