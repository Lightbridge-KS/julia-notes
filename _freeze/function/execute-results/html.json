{
  "hash": "2af88e5a8a5ad95310e735f2a6701798",
  "result": {
    "markdown": "# Function\n\n\n\nSee [Function](https://docs.julialang.org/en/v1/manual/functions/)\n\n## Declare a Function\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction sayhi(name)\n    println(\"Hi $name, it's great to see you!\")\nend\n#> sayhi (generic function with 1 method)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nsayhi(\"ðŸ˜¸\")\n#> Hi ðŸ˜¸, it's great to see you!\n```\n:::\n\n\n**Single line**\n\n::: {.cell}\n\n```{.julia .cell-code}\nsquare(x) = x^2\n#> square (generic function with 1 method)\n\nsquare(3)\n#> 9\n```\n:::\n\n## Return Keyword\n\nLike `R` the last line in the body of function is returned. \n\nIf you want to return prematurely use `return` keyword.\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction g(x,y)\n    return x * y\n    x + y\nend\n#> g (generic function with 1 method)\n\ng(1, 2)\n#> 2\n```\n:::\n\nIf function has no return value (called for side-effect), return `nothing` by convention.\n\n## Infix Function\n\n::: {.cell}\n\n```{.julia .cell-code}\n1 + 2 + 3\n#> 6\n\n+(1,2,3)\n#> 6\n```\n:::\n\n## Argument-type Declaration\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(n::Integer) = n â‰¤ 2 ? one(n) : fib(n-1) + fib(n-2)\n#> fib (generic function with 1 method)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nfib(4)\n#> 3\n```\n:::\n\n## Anonymous Function\n\n::: {.cell}\n\n```{.julia .cell-code}\nx -> x^2 + 2x - 1\n#> #31 (generic function with 1 method)\n```\n:::\n\nThe primary use for anonymous functions is passing them to functions which take other functions as arguments. \n\nUseful in `map(f, collection)`\n\n\n## Functional Programming\n\n \n### Map\n\n::: {.cell}\n\n```{.julia .cell-code}\nðŸ“– = [1.2, 2.7]\n#> 2-element Vector{Float64}:\n#>  1.2\n#>  2.7\n```\n:::\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(round, ðŸ“–)\n#> 2-element Vector{Float64}:\n#>  1.0\n#>  3.0\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nmap(x -> 2x + 1, ðŸ“–)\n#> 2-element Vector{Float64}:\n#>  3.4\n#>  6.4\n```\n:::\n\n\n### Broadcast\n\nShorter way is to `broadcast` a function.\n\n::: {.cell}\n\n```{.julia .cell-code}\nh(x) = 2x + 1\n#> h (generic function with 1 method)\nh.(ðŸ“–)\n#> 2-element Vector{Float64}:\n#>  3.4\n#>  6.4\n```\n:::\n\n\n## Destructuring Assignment\n\nA comma-separated list of variables (optionally wrapped in parentheses) can appear on the left side of an assignment: the value on the right side is destructured by iterating over and assigning to each variable in turn:\n\n::: {.cell}\n\n```{.julia .cell-code}\n(a,b,c) = 1:3 \n#> 1:3\n# or \na, b, c = 1:3\n#> 1:3\n\nb\n#> 2\n```\n:::\n\n\n## Multiple Return Values\n\nA tuple is useful for return multiple values from a function.\n\n::: {.cell}\n\n```{.julia .cell-code}\nfunction foo(a,b)\n    (add = a+b, prod = a*b)\nend\n#> foo (generic function with 1 method)\n```\n:::\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nx = foo(2,3)\n#> (add = 5, prod = 6)\n\nx\n#> (add = 5, prod = 6)\nx.add\n#> 5\n```\n:::\n\nDestructuring assignment extracts each value into a variable:\n\n::: {.cell}\n\n```{.julia .cell-code}\na, b = foo(4, 5)\n#> (add = 9, prod = 20)\n\na\n#> 9\nb\n#> 20\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}